package codingame.veryhard.theresistance

import codingames.veryhard.theresistance.Solution
import org.scalatest.FlatSpec

class SolutionTests extends FlatSpec {
//  I OJGDV FKCKM BZBSFE RFUJT CJKCX PBBJC RSVXE LISANTLE ZUVFD BXXFU ESATOMI HJXMQ RJOEB CQWVS ROZNN ITRNT VGCVWU WRQLY UQNTV TYDVR NQKPBI BMVZE NYUVQX RCODM STSUD ZGXPU FCQCTZ DXEXC AXZBH UHDWB QTLHV YJDGX UOFBCG BMIUH BANNAK MPLELALE LRGKJU DCQOQQ WQCWA TSJTB BTMKQ OUJOURSCE ILISSPARL HGQFY KNXRZ DEPERMETTANTDETRAN JQXXBP IVJUY DGZRXJ CEWBG LNOQF EIOHE YNUKH OHJXY IXQNP BTMMQ UIHEXK FALUN SCYOJ LDVGCI HSTBA XDMXL LETDU HQIJK CASWT ZKGUN TYTMS CNNZR KGSWYW KPVNGV XYVHL YPAOW GOVFN ROHQI ZYGYV LRVWBT PSPTO TCAVM NSDVC JIDAW UBYGB SCYNO LBCWS NRQXR NOUQP YFSPV JZIDJ BVASMD BUICK WWXAN HMDYF NZZUP QKKHY QSTOU WBKDM YYODA YQPGL DHDED YFXZS HEPCX SGSJK PLEKO TALGU DBWAA DAUTR DGIWG CRHUR SYKOU VQIPZ JKFAG VGNWT WLWZO QSBKG GGSTO CFKYX RXDOH CASZX GNPWT YOOOE OJFYK WNFOJ ZFIPK RMQAH WUYBI TEENCORECEJO CABRS PUYJO YHKQC VPXPO FERIR MYGUH SAFVR JLBDE VMFGR RXHQF LAPTZ RFCHR KYYXO SFVEQ MLHGF UTQAC AJMEF EWYDF BCSLM UGQXC DLGUXV SGMWI KVSQO MBYWD VCILU NLYPJW QZZJS USUCR NQVRO AUTRAFI TRESIGNAU WFSQF JPUKY KUJWL NCGUK TFPVG WQUNA ZPJXO UWYUB HGQDL REMORSEP BTVAQ TGFIQ UENC QNHPT GZBWS NXXCR EJTJN ATVTP OISZU STGMKK FSBQC NEEAK JFSZL ARZVZ KPPRE FEFCG BUSIT IVOQA NWNNA GIFIO VDZNEP AJLCY HJFEU UNOJN BAXZM AMRIY MKAEX JSVVWR VFEAJ QFVSE UEKNB SFBQB PNEET ODNZR BCCOKO OXAHB JMYLN MJUXJ EOUDAPPELEN CDAHG IXWKO VQOKR VFOIF RJTXC WAUVAH LEOIK AAKWH LXGSB WRMITJ CZPOAV NEWKP ISLTJ NJGME SVYZD THLAP DSLYRT AAKUR SGSBK VRMGA SJTBKA NJOVT TJMWXD VENIE RSFR LLMQC VGNBA TWWWS WPQABJ JXPHS YFRXR BFSHH ERNWU LKVSO JSEPP WLWKM XSCBBV RJNNA ROHYZ JCAQA ALORSENUT QQHGD DNPFY TQCVA SLTQH INTDB LSKHJN ZUOJKQ KQDOLF GPIQB JROVT MQNJML UTFJK VUBUQ CQSLZ UVISUELFL OXQJO JCIZS KUSPV BDDUT VDSKU POMLH MVPUK CKGTG FMMCY ZVRXZ JOSFTZ GYKCKU YXINT CXRHC CPMUE CHIFFRES JVQBC NRCEL MKQDX ZZVZIS LBLRTQ UJDBZ BXTFY NLHPM VWTNM EFYWP DIUTU PDPDOR TVIAUNSIGNALR XOTDP TYNTT OPTIMISERLEC GETNBI AXPMC WGYLG GKSVGL MYFYB CSRUK GNQHM CNVIO BHPRTP VBCYG FDFEFJ PDTEV CIXRH URDESFRQUENC BYUQP GPEPK TKOQC AEGAI GFDVTW TOAQF CQWEQ MENCEDCLINERLENT ADVHT IAKQZ WPRHJ VODLOF UURSL HSAHM SOVPD IDEPC TAXZTB KXFLY HPVRB TRJCE ADVKM JPYSC JMBIW EZPWVF RPRFR WSWHG EZARN IOYJY AZBOX HNKKX KIRAY DSVDG CDYRCM ELSCG MUYIP INTHH ZIQLW BIOTG VSHLH UWMUPM SMYXCQ LNPFAA ZGJWA UZNMH CWZMM HEOQK YIXWR OTCJR RHPQIJ ZAEIC SOVNI YWZNRG MENBP VXNMR YYNUI XBYLR UKIJN KXFJT LFXCV HRASESC OXGFXW VZYIYL GEBSY EMORSEESTCO UTFHO VLSOC UEKWS YWVIC MAYXO JLAMA KQVPV CWNDQ VERSUNCB EXTELAIDE HXKCL MSMPC YRZFG KMAJF JYMSI UAFJD OOIWD IBOJVV WHTZI KUTWID GBVEG CJAUG BBUBN PNQXE ZDLWZR IHNNR FKUIQ ETQGI RNZAT AKVQL CZOSY TGABV KYZJR CWZIA PZUDL KIZHN VUBMC EZANX NEWNX CZSBW AQHZZV XVSDR SIIMK QTXZS VRGWI JDBOUQ CRXWU SUGWE AJMUU DEONTE BPEHQ KNYIC NTERMITTENT XSOWK OISLK RSLFG PUZSG OFPPC UKIQY YOOZX HLJLQ WHBWB DIAMQ CZCJO WDBWBD JPYVE JKJRRZ XDCZY GJOAG OYVLZ AOKODF BOXTU AUFJM XIUME AFBOE QTFSL LZCGA YXITB IHNSJ ZHLPH JTXDT PZPGH ACVYS AYQPR YLNRB AINESETLE UWKPA TOQCK OUUNGESTEC ZDIHY SMLTQ OYFPW UYMVO BUIVR LSGLT AMRDZ JPEZI BVFOI REYXPI DDOEK XTKYM ZIQTA UDBBW VSEVMP WFAKU VKDAX LYHPI WVFDS TTXJL
  val seq = "......-...-..---.-----.-..-..-.."
  val seq2 = "-.-"
  val seq3 = "-....--.-.-.-"
  val dictNum = 5
  val dict = List("HELL", "HELLO", "OWORLD", "WORLD", "TEST")
  val dict2 = List("A", "B", "C", "HELLO", "K", "WORLD")
  val wordMap: scala.collection.mutable.Map[String, Int] = scala.collection.mutable.Map.empty[String, Int]

  "A solution" should "solve the problem" in {
    def wordPair(word: String) = {
      val mword = Solution.toMorze(word)
      if (wordMap.contains(mword)) wordMap.put(mword, wordMap(mword) + 1)
      else wordMap.put(mword, 1)
    }

    def find(seq: Stream[Char]): Int = {
      if (seq.isEmpty) 1 else {
        val res = for {
          indexedSeq <- seq.zipWithIndex
          candidate = seq.take(indexedSeq._2 + 1).foldLeft("")(_ + _)
          if wordMap.contains(candidate)
        } yield wordMap(candidate) * find(seq.drop(indexedSeq._2 + 1))
        res.sum
      }
    }

//    val a = 57330892800l
    val words = Array("BAC", "DUC", "AQUA", "BANN", "K", "BACK", "BANNK")

//    for (i <- dict.indices) wordPair(dict(i))
    for (i <- words.indices) wordPair(words(i))
//    val res = find(seq)
    val res = find(seq3.toStream)
//    Console.err.println(s"seq: $seq")
    Console.err.println(s"seq: $seq3")
//    Console.err.println(s"encoded: $dict")
    Console.err.println(s"res: $res")
    assert(res == 5)
  }
}
